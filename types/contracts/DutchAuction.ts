/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  EventFragment,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedLogDescription,
  TypedListener,
  TypedContractMethod,
} from "../common";

export interface DutchAuctionInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "approve"
      | "auctionDescription"
      | "auctionDuration"
      | "auctionEndTime"
      | "auctionEnded"
      | "auctionStartTime"
      | "auctionTitle"
      | "auctionType"
      | "bidders"
      | "bids"
      | "canClaimPayment"
      | "canClaimPrize"
      | "canClaimRefund"
      | "canReclaimNFT"
      | "claimPayment"
      | "claimPrize"
      | "claimRefund"
      | "confidentialProtocolId"
      | "decrementInterval"
      | "depositNFT"
      | "endAuction"
      | "factory"
      | "getAuctionMetadata"
      | "getAuctionState"
      | "getCurrentPrice"
      | "getDutchInfo"
      | "getNFTInfo"
      | "getPriceAtTime"
      | "getPriceDropCount"
      | "getPrivacyInfo"
      | "getStatistics"
      | "getTimeRemaining"
      | "getTimeToNextDrop"
      | "getWinnerInfo"
      | "hasNFT"
      | "hasReservePrice"
      | "isActive"
      | "isReadyForBidding"
      | "minimumBid"
      | "nftClaimed"
      | "nftContract"
      | "nftDeposited"
      | "nftTokenId"
      | "placeBid"
      | "priceDecrement"
      | "reclaimNFT"
      | "refundClaimed"
      | "reject"
      | "reserveMet"
      | "reservePrice"
      | "revealStatistics"
      | "revealWinner"
      | "revealedBidderCount"
      | "revealedTotalVolume"
      | "revealedWinningBid"
      | "seller"
      | "sellerClaimed"
      | "setReservePrice"
      | "startingPrice"
      | "statisticsRevealed"
      | "status"
      | "winner"
      | "winnerRevealed"
      | "winningPrice"
  ): FunctionFragment;

  getEvent(
    nameOrSignatureOrTopic:
      | "AuctionApproved"
      | "AuctionEnded"
      | "AuctionRejected"
      | "BidPlaced"
      | "NFTDeposited"
      | "NFTReclaimed"
      | "NFTTransferred"
      | "PaymentClaimed"
      | "PrizeClaimed"
      | "RefundClaimed"
      | "ReserveNotMet"
      | "SellerPaid"
      | "StatisticsRevealed"
      | "WinnerRevealed"
  ): EventFragment;

  encodeFunctionData(functionFragment: "approve", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "auctionDescription",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "auctionDuration",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "auctionEndTime",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "auctionEnded",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "auctionStartTime",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "auctionTitle",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "auctionType",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "bidders",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "bids", values: [AddressLike]): string;
  encodeFunctionData(
    functionFragment: "canClaimPayment",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "canClaimPrize",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "canClaimRefund",
    values: [AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "canReclaimNFT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "claimPayment",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "claimPrize",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "claimRefund",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "confidentialProtocolId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "decrementInterval",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "depositNFT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "endAuction",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "factory", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getAuctionMetadata",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getAuctionState",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrentPrice",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getDutchInfo",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getNFTInfo",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getPriceAtTime",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getPriceDropCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getPrivacyInfo",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getStatistics",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTimeRemaining",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTimeToNextDrop",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getWinnerInfo",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "hasNFT", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "hasReservePrice",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "isActive", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "isReadyForBidding",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "minimumBid",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nftClaimed",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nftContract",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nftDeposited",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nftTokenId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "placeBid",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "priceDecrement",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "reclaimNFT",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "refundClaimed",
    values: [AddressLike]
  ): string;
  encodeFunctionData(functionFragment: "reject", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "reserveMet",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "reservePrice",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "revealStatistics",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "revealWinner",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "revealedBidderCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "revealedTotalVolume",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "revealedWinningBid",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "seller", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "sellerClaimed",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setReservePrice",
    values: [BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "startingPrice",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "statisticsRevealed",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "status", values?: undefined): string;
  encodeFunctionData(functionFragment: "winner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "winnerRevealed",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "winningPrice",
    values?: undefined
  ): string;

  decodeFunctionResult(functionFragment: "approve", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "auctionDescription",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "auctionDuration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "auctionEndTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "auctionEnded",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "auctionStartTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "auctionTitle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "auctionType",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "bidders", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "bids", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "canClaimPayment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canClaimPrize",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canClaimRefund",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "canReclaimNFT",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimPayment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "claimPrize", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "claimRefund",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "confidentialProtocolId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "decrementInterval",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "depositNFT", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "endAuction", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "factory", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getAuctionMetadata",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAuctionState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDutchInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getNFTInfo", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getPriceAtTime",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPriceDropCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPrivacyInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStatistics",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTimeRemaining",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTimeToNextDrop",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getWinnerInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "hasNFT", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "hasReservePrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isActive", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "isReadyForBidding",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "minimumBid", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "nftClaimed", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "nftContract",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nftDeposited",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "nftTokenId", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "placeBid", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "priceDecrement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "reclaimNFT", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "refundClaimed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "reject", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "reserveMet", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "reservePrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revealStatistics",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revealWinner",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revealedBidderCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revealedTotalVolume",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revealedWinningBid",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "seller", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "sellerClaimed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReservePrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startingPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "statisticsRevealed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "status", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "winner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "winnerRevealed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "winningPrice",
    data: BytesLike
  ): Result;
}

export namespace AuctionApprovedEvent {
  export type InputTuple = [auction: AddressLike, timestamp: BigNumberish];
  export type OutputTuple = [auction: string, timestamp: bigint];
  export interface OutputObject {
    auction: string;
    timestamp: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace AuctionEndedEvent {
  export type InputTuple = [timestamp: BigNumberish];
  export type OutputTuple = [timestamp: bigint];
  export interface OutputObject {
    timestamp: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace AuctionRejectedEvent {
  export type InputTuple = [auction: AddressLike, timestamp: BigNumberish];
  export type OutputTuple = [auction: string, timestamp: bigint];
  export interface OutputObject {
    auction: string;
    timestamp: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace BidPlacedEvent {
  export type InputTuple = [
    bidder: AddressLike,
    escrowAmount: BigNumberish,
    timestamp: BigNumberish
  ];
  export type OutputTuple = [
    bidder: string,
    escrowAmount: bigint,
    timestamp: bigint
  ];
  export interface OutputObject {
    bidder: string;
    escrowAmount: bigint;
    timestamp: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace NFTDepositedEvent {
  export type InputTuple = [
    seller: AddressLike,
    nftContract: AddressLike,
    tokenId: BigNumberish
  ];
  export type OutputTuple = [
    seller: string,
    nftContract: string,
    tokenId: bigint
  ];
  export interface OutputObject {
    seller: string;
    nftContract: string;
    tokenId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace NFTReclaimedEvent {
  export type InputTuple = [
    seller: AddressLike,
    nftContract: AddressLike,
    tokenId: BigNumberish
  ];
  export type OutputTuple = [
    seller: string,
    nftContract: string,
    tokenId: bigint
  ];
  export interface OutputObject {
    seller: string;
    nftContract: string;
    tokenId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace NFTTransferredEvent {
  export type InputTuple = [
    to: AddressLike,
    nftContract: AddressLike,
    tokenId: BigNumberish
  ];
  export type OutputTuple = [to: string, nftContract: string, tokenId: bigint];
  export interface OutputObject {
    to: string;
    nftContract: string;
    tokenId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PaymentClaimedEvent {
  export type InputTuple = [seller: AddressLike, amount: BigNumberish];
  export type OutputTuple = [seller: string, amount: bigint];
  export interface OutputObject {
    seller: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace PrizeClaimedEvent {
  export type InputTuple = [
    winner: AddressLike,
    nftContract: AddressLike,
    tokenId: BigNumberish
  ];
  export type OutputTuple = [
    winner: string,
    nftContract: string,
    tokenId: bigint
  ];
  export interface OutputObject {
    winner: string;
    nftContract: string;
    tokenId: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace RefundClaimedEvent {
  export type InputTuple = [bidder: AddressLike, amount: BigNumberish];
  export type OutputTuple = [bidder: string, amount: bigint];
  export interface OutputObject {
    bidder: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace ReserveNotMetEvent {
  export type InputTuple = [timestamp: BigNumberish];
  export type OutputTuple = [timestamp: bigint];
  export interface OutputObject {
    timestamp: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace SellerPaidEvent {
  export type InputTuple = [seller: AddressLike, amount: BigNumberish];
  export type OutputTuple = [seller: string, amount: bigint];
  export interface OutputObject {
    seller: string;
    amount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace StatisticsRevealedEvent {
  export type InputTuple = [
    totalVolume: BigNumberish,
    bidderCount: BigNumberish
  ];
  export type OutputTuple = [totalVolume: bigint, bidderCount: bigint];
  export interface OutputObject {
    totalVolume: bigint;
    bidderCount: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export namespace WinnerRevealedEvent {
  export type InputTuple = [winner: AddressLike, winningBid: BigNumberish];
  export type OutputTuple = [winner: string, winningBid: bigint];
  export interface OutputObject {
    winner: string;
    winningBid: bigint;
  }
  export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
  export type Filter = TypedDeferredTopicFilter<Event>;
  export type Log = TypedEventLog<Event>;
  export type LogDescription = TypedLogDescription<Event>;
}

export interface DutchAuction extends BaseContract {
  connect(runner?: ContractRunner | null): DutchAuction;
  waitForDeployment(): Promise<this>;

  interface: DutchAuctionInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  approve: TypedContractMethod<[], [void], "nonpayable">;

  auctionDescription: TypedContractMethod<[], [string], "view">;

  auctionDuration: TypedContractMethod<[], [bigint], "view">;

  auctionEndTime: TypedContractMethod<[], [bigint], "view">;

  auctionEnded: TypedContractMethod<[], [boolean], "view">;

  auctionStartTime: TypedContractMethod<[], [bigint], "view">;

  auctionTitle: TypedContractMethod<[], [string], "view">;

  auctionType: TypedContractMethod<[], [bigint], "view">;

  bidders: TypedContractMethod<[arg0: BigNumberish], [string], "view">;

  bids: TypedContractMethod<
    [arg0: AddressLike],
    [
      [string, bigint, boolean] & {
        encryptedAmount: string;
        escrowAmount: bigint;
        exists: boolean;
      }
    ],
    "view"
  >;

  canClaimPayment: TypedContractMethod<[], [boolean], "view">;

  canClaimPrize: TypedContractMethod<[user: AddressLike], [boolean], "view">;

  canClaimRefund: TypedContractMethod<[user: AddressLike], [boolean], "view">;

  canReclaimNFT: TypedContractMethod<[], [boolean], "view">;

  claimPayment: TypedContractMethod<[], [void], "nonpayable">;

  claimPrize: TypedContractMethod<[], [void], "nonpayable">;

  claimRefund: TypedContractMethod<[], [void], "nonpayable">;

  confidentialProtocolId: TypedContractMethod<[], [bigint], "view">;

  decrementInterval: TypedContractMethod<[], [bigint], "view">;

  depositNFT: TypedContractMethod<[], [void], "nonpayable">;

  endAuction: TypedContractMethod<[], [void], "nonpayable">;

  factory: TypedContractMethod<[], [string], "view">;

  getAuctionMetadata: TypedContractMethod<
    [],
    [
      [string, string, string, bigint, bigint] & {
        title: string;
        description: string;
        auctionSeller: string;
        aType: bigint;
        minBid: bigint;
      }
    ],
    "view"
  >;

  getAuctionState: TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, boolean, bigint] & {
        aStatus: bigint;
        startTime: bigint;
        endTime: bigint;
        ended: boolean;
        bidderCount: bigint;
      }
    ],
    "view"
  >;

  getCurrentPrice: TypedContractMethod<[], [bigint], "view">;

  getDutchInfo: TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint, boolean] & {
        currentPrice: bigint;
        starting: bigint;
        reserve: bigint;
        decrement: bigint;
        interval: bigint;
        hasWinner: boolean;
      }
    ],
    "view"
  >;

  getNFTInfo: TypedContractMethod<
    [],
    [
      [boolean, string, bigint, boolean] & {
        isNFTAuction: boolean;
        nftContractAddress: string;
        tokenId: bigint;
        claimed: boolean;
      }
    ],
    "view"
  >;

  getPriceAtTime: TypedContractMethod<
    [timestamp: BigNumberish],
    [bigint],
    "view"
  >;

  getPriceDropCount: TypedContractMethod<[], [bigint], "view">;

  getPrivacyInfo: TypedContractMethod<
    [],
    [
      [boolean, boolean, boolean] & {
        hasReserve: boolean;
        isReserveMet: boolean;
        bidderCountHidden: boolean;
      }
    ],
    "view"
  >;

  getStatistics: TypedContractMethod<
    [],
    [
      [bigint, bigint, boolean] & {
        totalVolume: bigint;
        avgBid: bigint;
        isRevealed: boolean;
      }
    ],
    "view"
  >;

  getTimeRemaining: TypedContractMethod<[], [bigint], "view">;

  getTimeToNextDrop: TypedContractMethod<[], [bigint], "view">;

  getWinnerInfo: TypedContractMethod<
    [],
    [
      [string, bigint, boolean] & {
        winnerAddress: string;
        winningBidAmount: bigint;
        isRevealed: boolean;
      }
    ],
    "view"
  >;

  hasNFT: TypedContractMethod<[], [boolean], "view">;

  hasReservePrice: TypedContractMethod<[], [boolean], "view">;

  isActive: TypedContractMethod<[], [boolean], "view">;

  isReadyForBidding: TypedContractMethod<
    [],
    [[boolean, string] & { ready: boolean; reason: string }],
    "view"
  >;

  minimumBid: TypedContractMethod<[], [bigint], "view">;

  nftClaimed: TypedContractMethod<[], [boolean], "view">;

  nftContract: TypedContractMethod<[], [string], "view">;

  nftDeposited: TypedContractMethod<[], [boolean], "view">;

  nftTokenId: TypedContractMethod<[], [bigint], "view">;

  placeBid: TypedContractMethod<
    [encryptedBid: BytesLike, inputProof: BytesLike],
    [void],
    "payable"
  >;

  priceDecrement: TypedContractMethod<[], [bigint], "view">;

  reclaimNFT: TypedContractMethod<[], [void], "nonpayable">;

  refundClaimed: TypedContractMethod<[arg0: AddressLike], [boolean], "view">;

  reject: TypedContractMethod<[], [void], "nonpayable">;

  reserveMet: TypedContractMethod<[], [boolean], "view">;

  reservePrice: TypedContractMethod<[], [bigint], "view">;

  revealStatistics: TypedContractMethod<
    [decryptedTotal: BigNumberish, proof: BytesLike],
    [void],
    "nonpayable"
  >;

  revealWinner: TypedContractMethod<
    [arg0: BigNumberish, arg1: BigNumberish, arg2: BytesLike],
    [void],
    "view"
  >;

  revealedBidderCount: TypedContractMethod<[], [bigint], "view">;

  revealedTotalVolume: TypedContractMethod<[], [bigint], "view">;

  revealedWinningBid: TypedContractMethod<[], [bigint], "view">;

  seller: TypedContractMethod<[], [string], "view">;

  sellerClaimed: TypedContractMethod<[], [boolean], "view">;

  setReservePrice: TypedContractMethod<
    [encryptedReserve: BytesLike, inputProof: BytesLike],
    [void],
    "nonpayable"
  >;

  startingPrice: TypedContractMethod<[], [bigint], "view">;

  statisticsRevealed: TypedContractMethod<[], [boolean], "view">;

  status: TypedContractMethod<[], [bigint], "view">;

  winner: TypedContractMethod<[], [string], "view">;

  winnerRevealed: TypedContractMethod<[], [boolean], "view">;

  winningPrice: TypedContractMethod<[], [bigint], "view">;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "approve"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "auctionDescription"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "auctionDuration"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "auctionEndTime"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "auctionEnded"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "auctionStartTime"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "auctionTitle"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "auctionType"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "bidders"
  ): TypedContractMethod<[arg0: BigNumberish], [string], "view">;
  getFunction(
    nameOrSignature: "bids"
  ): TypedContractMethod<
    [arg0: AddressLike],
    [
      [string, bigint, boolean] & {
        encryptedAmount: string;
        escrowAmount: bigint;
        exists: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "canClaimPayment"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "canClaimPrize"
  ): TypedContractMethod<[user: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "canClaimRefund"
  ): TypedContractMethod<[user: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "canReclaimNFT"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "claimPayment"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "claimPrize"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "claimRefund"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "confidentialProtocolId"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "decrementInterval"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "depositNFT"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "endAuction"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "factory"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "getAuctionMetadata"
  ): TypedContractMethod<
    [],
    [
      [string, string, string, bigint, bigint] & {
        title: string;
        description: string;
        auctionSeller: string;
        aType: bigint;
        minBid: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getAuctionState"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, boolean, bigint] & {
        aStatus: bigint;
        startTime: bigint;
        endTime: bigint;
        ended: boolean;
        bidderCount: bigint;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getCurrentPrice"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getDutchInfo"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, bigint, bigint, bigint, boolean] & {
        currentPrice: bigint;
        starting: bigint;
        reserve: bigint;
        decrement: bigint;
        interval: bigint;
        hasWinner: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getNFTInfo"
  ): TypedContractMethod<
    [],
    [
      [boolean, string, bigint, boolean] & {
        isNFTAuction: boolean;
        nftContractAddress: string;
        tokenId: bigint;
        claimed: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getPriceAtTime"
  ): TypedContractMethod<[timestamp: BigNumberish], [bigint], "view">;
  getFunction(
    nameOrSignature: "getPriceDropCount"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getPrivacyInfo"
  ): TypedContractMethod<
    [],
    [
      [boolean, boolean, boolean] & {
        hasReserve: boolean;
        isReserveMet: boolean;
        bidderCountHidden: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getStatistics"
  ): TypedContractMethod<
    [],
    [
      [bigint, bigint, boolean] & {
        totalVolume: bigint;
        avgBid: bigint;
        isRevealed: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getTimeRemaining"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getTimeToNextDrop"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "getWinnerInfo"
  ): TypedContractMethod<
    [],
    [
      [string, bigint, boolean] & {
        winnerAddress: string;
        winningBidAmount: bigint;
        isRevealed: boolean;
      }
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "hasNFT"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "hasReservePrice"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "isActive"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "isReadyForBidding"
  ): TypedContractMethod<
    [],
    [[boolean, string] & { ready: boolean; reason: string }],
    "view"
  >;
  getFunction(
    nameOrSignature: "minimumBid"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "nftClaimed"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "nftContract"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "nftDeposited"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "nftTokenId"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "placeBid"
  ): TypedContractMethod<
    [encryptedBid: BytesLike, inputProof: BytesLike],
    [void],
    "payable"
  >;
  getFunction(
    nameOrSignature: "priceDecrement"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "reclaimNFT"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "refundClaimed"
  ): TypedContractMethod<[arg0: AddressLike], [boolean], "view">;
  getFunction(
    nameOrSignature: "reject"
  ): TypedContractMethod<[], [void], "nonpayable">;
  getFunction(
    nameOrSignature: "reserveMet"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "reservePrice"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "revealStatistics"
  ): TypedContractMethod<
    [decryptedTotal: BigNumberish, proof: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "revealWinner"
  ): TypedContractMethod<
    [arg0: BigNumberish, arg1: BigNumberish, arg2: BytesLike],
    [void],
    "view"
  >;
  getFunction(
    nameOrSignature: "revealedBidderCount"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "revealedTotalVolume"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "revealedWinningBid"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "seller"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "sellerClaimed"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "setReservePrice"
  ): TypedContractMethod<
    [encryptedReserve: BytesLike, inputProof: BytesLike],
    [void],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "startingPrice"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "statisticsRevealed"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "status"
  ): TypedContractMethod<[], [bigint], "view">;
  getFunction(
    nameOrSignature: "winner"
  ): TypedContractMethod<[], [string], "view">;
  getFunction(
    nameOrSignature: "winnerRevealed"
  ): TypedContractMethod<[], [boolean], "view">;
  getFunction(
    nameOrSignature: "winningPrice"
  ): TypedContractMethod<[], [bigint], "view">;

  getEvent(
    key: "AuctionApproved"
  ): TypedContractEvent<
    AuctionApprovedEvent.InputTuple,
    AuctionApprovedEvent.OutputTuple,
    AuctionApprovedEvent.OutputObject
  >;
  getEvent(
    key: "AuctionEnded"
  ): TypedContractEvent<
    AuctionEndedEvent.InputTuple,
    AuctionEndedEvent.OutputTuple,
    AuctionEndedEvent.OutputObject
  >;
  getEvent(
    key: "AuctionRejected"
  ): TypedContractEvent<
    AuctionRejectedEvent.InputTuple,
    AuctionRejectedEvent.OutputTuple,
    AuctionRejectedEvent.OutputObject
  >;
  getEvent(
    key: "BidPlaced"
  ): TypedContractEvent<
    BidPlacedEvent.InputTuple,
    BidPlacedEvent.OutputTuple,
    BidPlacedEvent.OutputObject
  >;
  getEvent(
    key: "NFTDeposited"
  ): TypedContractEvent<
    NFTDepositedEvent.InputTuple,
    NFTDepositedEvent.OutputTuple,
    NFTDepositedEvent.OutputObject
  >;
  getEvent(
    key: "NFTReclaimed"
  ): TypedContractEvent<
    NFTReclaimedEvent.InputTuple,
    NFTReclaimedEvent.OutputTuple,
    NFTReclaimedEvent.OutputObject
  >;
  getEvent(
    key: "NFTTransferred"
  ): TypedContractEvent<
    NFTTransferredEvent.InputTuple,
    NFTTransferredEvent.OutputTuple,
    NFTTransferredEvent.OutputObject
  >;
  getEvent(
    key: "PaymentClaimed"
  ): TypedContractEvent<
    PaymentClaimedEvent.InputTuple,
    PaymentClaimedEvent.OutputTuple,
    PaymentClaimedEvent.OutputObject
  >;
  getEvent(
    key: "PrizeClaimed"
  ): TypedContractEvent<
    PrizeClaimedEvent.InputTuple,
    PrizeClaimedEvent.OutputTuple,
    PrizeClaimedEvent.OutputObject
  >;
  getEvent(
    key: "RefundClaimed"
  ): TypedContractEvent<
    RefundClaimedEvent.InputTuple,
    RefundClaimedEvent.OutputTuple,
    RefundClaimedEvent.OutputObject
  >;
  getEvent(
    key: "ReserveNotMet"
  ): TypedContractEvent<
    ReserveNotMetEvent.InputTuple,
    ReserveNotMetEvent.OutputTuple,
    ReserveNotMetEvent.OutputObject
  >;
  getEvent(
    key: "SellerPaid"
  ): TypedContractEvent<
    SellerPaidEvent.InputTuple,
    SellerPaidEvent.OutputTuple,
    SellerPaidEvent.OutputObject
  >;
  getEvent(
    key: "StatisticsRevealed"
  ): TypedContractEvent<
    StatisticsRevealedEvent.InputTuple,
    StatisticsRevealedEvent.OutputTuple,
    StatisticsRevealedEvent.OutputObject
  >;
  getEvent(
    key: "WinnerRevealed"
  ): TypedContractEvent<
    WinnerRevealedEvent.InputTuple,
    WinnerRevealedEvent.OutputTuple,
    WinnerRevealedEvent.OutputObject
  >;

  filters: {
    "AuctionApproved(address,uint256)": TypedContractEvent<
      AuctionApprovedEvent.InputTuple,
      AuctionApprovedEvent.OutputTuple,
      AuctionApprovedEvent.OutputObject
    >;
    AuctionApproved: TypedContractEvent<
      AuctionApprovedEvent.InputTuple,
      AuctionApprovedEvent.OutputTuple,
      AuctionApprovedEvent.OutputObject
    >;

    "AuctionEnded(uint256)": TypedContractEvent<
      AuctionEndedEvent.InputTuple,
      AuctionEndedEvent.OutputTuple,
      AuctionEndedEvent.OutputObject
    >;
    AuctionEnded: TypedContractEvent<
      AuctionEndedEvent.InputTuple,
      AuctionEndedEvent.OutputTuple,
      AuctionEndedEvent.OutputObject
    >;

    "AuctionRejected(address,uint256)": TypedContractEvent<
      AuctionRejectedEvent.InputTuple,
      AuctionRejectedEvent.OutputTuple,
      AuctionRejectedEvent.OutputObject
    >;
    AuctionRejected: TypedContractEvent<
      AuctionRejectedEvent.InputTuple,
      AuctionRejectedEvent.OutputTuple,
      AuctionRejectedEvent.OutputObject
    >;

    "BidPlaced(address,uint256,uint256)": TypedContractEvent<
      BidPlacedEvent.InputTuple,
      BidPlacedEvent.OutputTuple,
      BidPlacedEvent.OutputObject
    >;
    BidPlaced: TypedContractEvent<
      BidPlacedEvent.InputTuple,
      BidPlacedEvent.OutputTuple,
      BidPlacedEvent.OutputObject
    >;

    "NFTDeposited(address,address,uint256)": TypedContractEvent<
      NFTDepositedEvent.InputTuple,
      NFTDepositedEvent.OutputTuple,
      NFTDepositedEvent.OutputObject
    >;
    NFTDeposited: TypedContractEvent<
      NFTDepositedEvent.InputTuple,
      NFTDepositedEvent.OutputTuple,
      NFTDepositedEvent.OutputObject
    >;

    "NFTReclaimed(address,address,uint256)": TypedContractEvent<
      NFTReclaimedEvent.InputTuple,
      NFTReclaimedEvent.OutputTuple,
      NFTReclaimedEvent.OutputObject
    >;
    NFTReclaimed: TypedContractEvent<
      NFTReclaimedEvent.InputTuple,
      NFTReclaimedEvent.OutputTuple,
      NFTReclaimedEvent.OutputObject
    >;

    "NFTTransferred(address,address,uint256)": TypedContractEvent<
      NFTTransferredEvent.InputTuple,
      NFTTransferredEvent.OutputTuple,
      NFTTransferredEvent.OutputObject
    >;
    NFTTransferred: TypedContractEvent<
      NFTTransferredEvent.InputTuple,
      NFTTransferredEvent.OutputTuple,
      NFTTransferredEvent.OutputObject
    >;

    "PaymentClaimed(address,uint256)": TypedContractEvent<
      PaymentClaimedEvent.InputTuple,
      PaymentClaimedEvent.OutputTuple,
      PaymentClaimedEvent.OutputObject
    >;
    PaymentClaimed: TypedContractEvent<
      PaymentClaimedEvent.InputTuple,
      PaymentClaimedEvent.OutputTuple,
      PaymentClaimedEvent.OutputObject
    >;

    "PrizeClaimed(address,address,uint256)": TypedContractEvent<
      PrizeClaimedEvent.InputTuple,
      PrizeClaimedEvent.OutputTuple,
      PrizeClaimedEvent.OutputObject
    >;
    PrizeClaimed: TypedContractEvent<
      PrizeClaimedEvent.InputTuple,
      PrizeClaimedEvent.OutputTuple,
      PrizeClaimedEvent.OutputObject
    >;

    "RefundClaimed(address,uint256)": TypedContractEvent<
      RefundClaimedEvent.InputTuple,
      RefundClaimedEvent.OutputTuple,
      RefundClaimedEvent.OutputObject
    >;
    RefundClaimed: TypedContractEvent<
      RefundClaimedEvent.InputTuple,
      RefundClaimedEvent.OutputTuple,
      RefundClaimedEvent.OutputObject
    >;

    "ReserveNotMet(uint256)": TypedContractEvent<
      ReserveNotMetEvent.InputTuple,
      ReserveNotMetEvent.OutputTuple,
      ReserveNotMetEvent.OutputObject
    >;
    ReserveNotMet: TypedContractEvent<
      ReserveNotMetEvent.InputTuple,
      ReserveNotMetEvent.OutputTuple,
      ReserveNotMetEvent.OutputObject
    >;

    "SellerPaid(address,uint256)": TypedContractEvent<
      SellerPaidEvent.InputTuple,
      SellerPaidEvent.OutputTuple,
      SellerPaidEvent.OutputObject
    >;
    SellerPaid: TypedContractEvent<
      SellerPaidEvent.InputTuple,
      SellerPaidEvent.OutputTuple,
      SellerPaidEvent.OutputObject
    >;

    "StatisticsRevealed(uint256,uint256)": TypedContractEvent<
      StatisticsRevealedEvent.InputTuple,
      StatisticsRevealedEvent.OutputTuple,
      StatisticsRevealedEvent.OutputObject
    >;
    StatisticsRevealed: TypedContractEvent<
      StatisticsRevealedEvent.InputTuple,
      StatisticsRevealedEvent.OutputTuple,
      StatisticsRevealedEvent.OutputObject
    >;

    "WinnerRevealed(address,uint256)": TypedContractEvent<
      WinnerRevealedEvent.InputTuple,
      WinnerRevealedEvent.OutputTuple,
      WinnerRevealedEvent.OutputObject
    >;
    WinnerRevealed: TypedContractEvent<
      WinnerRevealedEvent.InputTuple,
      WinnerRevealedEvent.OutputTuple,
      WinnerRevealedEvent.OutputObject
    >;
  };
}
