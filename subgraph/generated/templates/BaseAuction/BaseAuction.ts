// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class AuctionApproved extends ethereum.Event {
  get params(): AuctionApproved__Params {
    return new AuctionApproved__Params(this);
  }
}

export class AuctionApproved__Params {
  _event: AuctionApproved;

  constructor(event: AuctionApproved) {
    this._event = event;
  }

  get auction(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get timestamp(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class AuctionEnded extends ethereum.Event {
  get params(): AuctionEnded__Params {
    return new AuctionEnded__Params(this);
  }
}

export class AuctionEnded__Params {
  _event: AuctionEnded;

  constructor(event: AuctionEnded) {
    this._event = event;
  }

  get timestamp(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class AuctionRejected extends ethereum.Event {
  get params(): AuctionRejected__Params {
    return new AuctionRejected__Params(this);
  }
}

export class AuctionRejected__Params {
  _event: AuctionRejected;

  constructor(event: AuctionRejected) {
    this._event = event;
  }

  get auction(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get timestamp(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class BidPlaced extends ethereum.Event {
  get params(): BidPlaced__Params {
    return new BidPlaced__Params(this);
  }
}

export class BidPlaced__Params {
  _event: BidPlaced;

  constructor(event: BidPlaced) {
    this._event = event;
  }

  get bidder(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get escrowAmount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get timestamp(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class NFTDeposited extends ethereum.Event {
  get params(): NFTDeposited__Params {
    return new NFTDeposited__Params(this);
  }
}

export class NFTDeposited__Params {
  _event: NFTDeposited;

  constructor(event: NFTDeposited) {
    this._event = event;
  }

  get seller(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get nftContract(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class NFTReclaimed extends ethereum.Event {
  get params(): NFTReclaimed__Params {
    return new NFTReclaimed__Params(this);
  }
}

export class NFTReclaimed__Params {
  _event: NFTReclaimed;

  constructor(event: NFTReclaimed) {
    this._event = event;
  }

  get seller(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get nftContract(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class NFTTransferred extends ethereum.Event {
  get params(): NFTTransferred__Params {
    return new NFTTransferred__Params(this);
  }
}

export class NFTTransferred__Params {
  _event: NFTTransferred;

  constructor(event: NFTTransferred) {
    this._event = event;
  }

  get to(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get nftContract(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class PaymentClaimed extends ethereum.Event {
  get params(): PaymentClaimed__Params {
    return new PaymentClaimed__Params(this);
  }
}

export class PaymentClaimed__Params {
  _event: PaymentClaimed;

  constructor(event: PaymentClaimed) {
    this._event = event;
  }

  get seller(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class PrizeClaimed extends ethereum.Event {
  get params(): PrizeClaimed__Params {
    return new PrizeClaimed__Params(this);
  }
}

export class PrizeClaimed__Params {
  _event: PrizeClaimed;

  constructor(event: PrizeClaimed) {
    this._event = event;
  }

  get winner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get nftContract(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get tokenId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class RefundClaimed extends ethereum.Event {
  get params(): RefundClaimed__Params {
    return new RefundClaimed__Params(this);
  }
}

export class RefundClaimed__Params {
  _event: RefundClaimed;

  constructor(event: RefundClaimed) {
    this._event = event;
  }

  get bidder(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class ReserveNotMet extends ethereum.Event {
  get params(): ReserveNotMet__Params {
    return new ReserveNotMet__Params(this);
  }
}

export class ReserveNotMet__Params {
  _event: ReserveNotMet;

  constructor(event: ReserveNotMet) {
    this._event = event;
  }

  get timestamp(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }
}

export class SellerPaid extends ethereum.Event {
  get params(): SellerPaid__Params {
    return new SellerPaid__Params(this);
  }
}

export class SellerPaid__Params {
  _event: SellerPaid;

  constructor(event: SellerPaid) {
    this._event = event;
  }

  get seller(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class StatisticsRevealed extends ethereum.Event {
  get params(): StatisticsRevealed__Params {
    return new StatisticsRevealed__Params(this);
  }
}

export class StatisticsRevealed__Params {
  _event: StatisticsRevealed;

  constructor(event: StatisticsRevealed) {
    this._event = event;
  }

  get totalVolume(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get bidderCount(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class WinnerRevealed extends ethereum.Event {
  get params(): WinnerRevealed__Params {
    return new WinnerRevealed__Params(this);
  }
}

export class WinnerRevealed__Params {
  _event: WinnerRevealed;

  constructor(event: WinnerRevealed) {
    this._event = event;
  }

  get winner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get winningBid(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class BaseAuction__bidsResult {
  value0: Bytes;
  value1: BigInt;
  value2: boolean;

  constructor(value0: Bytes, value1: BigInt, value2: boolean) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromFixedBytes(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromBoolean(this.value2));
    return map;
  }

  getEncryptedAmount(): Bytes {
    return this.value0;
  }

  getEscrowAmount(): BigInt {
    return this.value1;
  }

  getExists(): boolean {
    return this.value2;
  }
}

export class BaseAuction__getAuctionMetadataResult {
  value0: string;
  value1: string;
  value2: Address;
  value3: BigInt;

  constructor(value0: string, value1: string, value2: Address, value3: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromString(this.value0));
    map.set("value1", ethereum.Value.fromString(this.value1));
    map.set("value2", ethereum.Value.fromAddress(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    return map;
  }

  getTitle(): string {
    return this.value0;
  }

  getDescription(): string {
    return this.value1;
  }

  getAuctionSeller(): Address {
    return this.value2;
  }

  getMinBid(): BigInt {
    return this.value3;
  }
}

export class BaseAuction__getAuctionStateResult {
  value0: i32;
  value1: BigInt;
  value2: BigInt;
  value3: boolean;
  value4: BigInt;

  constructor(
    value0: i32,
    value1: BigInt,
    value2: BigInt,
    value3: boolean,
    value4: BigInt,
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set(
      "value0",
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(this.value0)),
    );
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromBoolean(this.value3));
    map.set("value4", ethereum.Value.fromUnsignedBigInt(this.value4));
    return map;
  }

  getAStatus(): i32 {
    return this.value0;
  }

  getStartTime(): BigInt {
    return this.value1;
  }

  getEndTime(): BigInt {
    return this.value2;
  }

  getEnded(): boolean {
    return this.value3;
  }

  getBidderCount(): BigInt {
    return this.value4;
  }
}

export class BaseAuction__getNFTInfoResult {
  value0: boolean;
  value1: Address;
  value2: BigInt;
  value3: boolean;

  constructor(
    value0: boolean,
    value1: Address,
    value2: BigInt,
    value3: boolean,
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBoolean(this.value0));
    map.set("value1", ethereum.Value.fromAddress(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromBoolean(this.value3));
    return map;
  }

  getIsNFTAuction(): boolean {
    return this.value0;
  }

  getNftContractAddress(): Address {
    return this.value1;
  }

  getTokenId(): BigInt {
    return this.value2;
  }

  getClaimed(): boolean {
    return this.value3;
  }
}

export class BaseAuction__getPrivacyInfoResult {
  value0: boolean;
  value1: boolean;
  value2: boolean;

  constructor(value0: boolean, value1: boolean, value2: boolean) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBoolean(this.value0));
    map.set("value1", ethereum.Value.fromBoolean(this.value1));
    map.set("value2", ethereum.Value.fromBoolean(this.value2));
    return map;
  }

  getHasReserve(): boolean {
    return this.value0;
  }

  getIsReserveMet(): boolean {
    return this.value1;
  }

  getBidderCountHidden(): boolean {
    return this.value2;
  }
}

export class BaseAuction__getStatisticsResult {
  value0: BigInt;
  value1: BigInt;
  value2: boolean;

  constructor(value0: BigInt, value1: BigInt, value2: boolean) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromBoolean(this.value2));
    return map;
  }

  getTotalVolume(): BigInt {
    return this.value0;
  }

  getAvgBid(): BigInt {
    return this.value1;
  }

  getIsRevealed(): boolean {
    return this.value2;
  }
}

export class BaseAuction__getWinnerInfoResult {
  value0: Address;
  value1: BigInt;
  value2: boolean;

  constructor(value0: Address, value1: BigInt, value2: boolean) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddress(this.value0));
    map.set("value1", ethereum.Value.fromUnsignedBigInt(this.value1));
    map.set("value2", ethereum.Value.fromBoolean(this.value2));
    return map;
  }

  getWinnerAddress(): Address {
    return this.value0;
  }

  getWinningBidAmount(): BigInt {
    return this.value1;
  }

  getIsRevealed(): boolean {
    return this.value2;
  }
}

export class BaseAuction__isReadyForBiddingResult {
  value0: boolean;
  value1: string;

  constructor(value0: boolean, value1: string) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBoolean(this.value0));
    map.set("value1", ethereum.Value.fromString(this.value1));
    return map;
  }

  getReady(): boolean {
    return this.value0;
  }

  getReason(): string {
    return this.value1;
  }
}

export class BaseAuction extends ethereum.SmartContract {
  static bind(address: Address): BaseAuction {
    return new BaseAuction("BaseAuction", address);
  }

  auctionDescription(): string {
    let result = super.call(
      "auctionDescription",
      "auctionDescription():(string)",
      [],
    );

    return result[0].toString();
  }

  try_auctionDescription(): ethereum.CallResult<string> {
    let result = super.tryCall(
      "auctionDescription",
      "auctionDescription():(string)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  auctionDuration(): BigInt {
    let result = super.call(
      "auctionDuration",
      "auctionDuration():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_auctionDuration(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "auctionDuration",
      "auctionDuration():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  auctionEndTime(): BigInt {
    let result = super.call("auctionEndTime", "auctionEndTime():(uint256)", []);

    return result[0].toBigInt();
  }

  try_auctionEndTime(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "auctionEndTime",
      "auctionEndTime():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  auctionEnded(): boolean {
    let result = super.call("auctionEnded", "auctionEnded():(bool)", []);

    return result[0].toBoolean();
  }

  try_auctionEnded(): ethereum.CallResult<boolean> {
    let result = super.tryCall("auctionEnded", "auctionEnded():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  auctionStartTime(): BigInt {
    let result = super.call(
      "auctionStartTime",
      "auctionStartTime():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_auctionStartTime(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "auctionStartTime",
      "auctionStartTime():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  auctionTitle(): string {
    let result = super.call("auctionTitle", "auctionTitle():(string)", []);

    return result[0].toString();
  }

  try_auctionTitle(): ethereum.CallResult<string> {
    let result = super.tryCall("auctionTitle", "auctionTitle():(string)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  bidders(param0: BigInt): Address {
    let result = super.call("bidders", "bidders(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(param0),
    ]);

    return result[0].toAddress();
  }

  try_bidders(param0: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall("bidders", "bidders(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(param0),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  bids(param0: Address): BaseAuction__bidsResult {
    let result = super.call("bids", "bids(address):(bytes32,uint256,bool)", [
      ethereum.Value.fromAddress(param0),
    ]);

    return new BaseAuction__bidsResult(
      result[0].toBytes(),
      result[1].toBigInt(),
      result[2].toBoolean(),
    );
  }

  try_bids(param0: Address): ethereum.CallResult<BaseAuction__bidsResult> {
    let result = super.tryCall("bids", "bids(address):(bytes32,uint256,bool)", [
      ethereum.Value.fromAddress(param0),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BaseAuction__bidsResult(
        value[0].toBytes(),
        value[1].toBigInt(),
        value[2].toBoolean(),
      ),
    );
  }

  canClaimPayment(): boolean {
    let result = super.call("canClaimPayment", "canClaimPayment():(bool)", []);

    return result[0].toBoolean();
  }

  try_canClaimPayment(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "canClaimPayment",
      "canClaimPayment():(bool)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  canClaimPrize(user: Address): boolean {
    let result = super.call("canClaimPrize", "canClaimPrize(address):(bool)", [
      ethereum.Value.fromAddress(user),
    ]);

    return result[0].toBoolean();
  }

  try_canClaimPrize(user: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "canClaimPrize",
      "canClaimPrize(address):(bool)",
      [ethereum.Value.fromAddress(user)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  canClaimRefund(user: Address): boolean {
    let result = super.call(
      "canClaimRefund",
      "canClaimRefund(address):(bool)",
      [ethereum.Value.fromAddress(user)],
    );

    return result[0].toBoolean();
  }

  try_canClaimRefund(user: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "canClaimRefund",
      "canClaimRefund(address):(bool)",
      [ethereum.Value.fromAddress(user)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  canReclaimNFT(): boolean {
    let result = super.call("canReclaimNFT", "canReclaimNFT():(bool)", []);

    return result[0].toBoolean();
  }

  try_canReclaimNFT(): ethereum.CallResult<boolean> {
    let result = super.tryCall("canReclaimNFT", "canReclaimNFT():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  confidentialProtocolId(): BigInt {
    let result = super.call(
      "confidentialProtocolId",
      "confidentialProtocolId():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_confidentialProtocolId(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "confidentialProtocolId",
      "confidentialProtocolId():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  factory(): Address {
    let result = super.call("factory", "factory():(address)", []);

    return result[0].toAddress();
  }

  try_factory(): ethereum.CallResult<Address> {
    let result = super.tryCall("factory", "factory():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  getAuctionMetadata(): BaseAuction__getAuctionMetadataResult {
    let result = super.call(
      "getAuctionMetadata",
      "getAuctionMetadata():(string,string,address,uint256)",
      [],
    );

    return new BaseAuction__getAuctionMetadataResult(
      result[0].toString(),
      result[1].toString(),
      result[2].toAddress(),
      result[3].toBigInt(),
    );
  }

  try_getAuctionMetadata(): ethereum.CallResult<BaseAuction__getAuctionMetadataResult> {
    let result = super.tryCall(
      "getAuctionMetadata",
      "getAuctionMetadata():(string,string,address,uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BaseAuction__getAuctionMetadataResult(
        value[0].toString(),
        value[1].toString(),
        value[2].toAddress(),
        value[3].toBigInt(),
      ),
    );
  }

  getAuctionState(): BaseAuction__getAuctionStateResult {
    let result = super.call(
      "getAuctionState",
      "getAuctionState():(uint8,uint256,uint256,bool,uint256)",
      [],
    );

    return new BaseAuction__getAuctionStateResult(
      result[0].toI32(),
      result[1].toBigInt(),
      result[2].toBigInt(),
      result[3].toBoolean(),
      result[4].toBigInt(),
    );
  }

  try_getAuctionState(): ethereum.CallResult<BaseAuction__getAuctionStateResult> {
    let result = super.tryCall(
      "getAuctionState",
      "getAuctionState():(uint8,uint256,uint256,bool,uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BaseAuction__getAuctionStateResult(
        value[0].toI32(),
        value[1].toBigInt(),
        value[2].toBigInt(),
        value[3].toBoolean(),
        value[4].toBigInt(),
      ),
    );
  }

  getNFTInfo(): BaseAuction__getNFTInfoResult {
    let result = super.call(
      "getNFTInfo",
      "getNFTInfo():(bool,address,uint256,bool)",
      [],
    );

    return new BaseAuction__getNFTInfoResult(
      result[0].toBoolean(),
      result[1].toAddress(),
      result[2].toBigInt(),
      result[3].toBoolean(),
    );
  }

  try_getNFTInfo(): ethereum.CallResult<BaseAuction__getNFTInfoResult> {
    let result = super.tryCall(
      "getNFTInfo",
      "getNFTInfo():(bool,address,uint256,bool)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BaseAuction__getNFTInfoResult(
        value[0].toBoolean(),
        value[1].toAddress(),
        value[2].toBigInt(),
        value[3].toBoolean(),
      ),
    );
  }

  getPrivacyInfo(): BaseAuction__getPrivacyInfoResult {
    let result = super.call(
      "getPrivacyInfo",
      "getPrivacyInfo():(bool,bool,bool)",
      [],
    );

    return new BaseAuction__getPrivacyInfoResult(
      result[0].toBoolean(),
      result[1].toBoolean(),
      result[2].toBoolean(),
    );
  }

  try_getPrivacyInfo(): ethereum.CallResult<BaseAuction__getPrivacyInfoResult> {
    let result = super.tryCall(
      "getPrivacyInfo",
      "getPrivacyInfo():(bool,bool,bool)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BaseAuction__getPrivacyInfoResult(
        value[0].toBoolean(),
        value[1].toBoolean(),
        value[2].toBoolean(),
      ),
    );
  }

  getStatistics(): BaseAuction__getStatisticsResult {
    let result = super.call(
      "getStatistics",
      "getStatistics():(uint256,uint256,bool)",
      [],
    );

    return new BaseAuction__getStatisticsResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBoolean(),
    );
  }

  try_getStatistics(): ethereum.CallResult<BaseAuction__getStatisticsResult> {
    let result = super.tryCall(
      "getStatistics",
      "getStatistics():(uint256,uint256,bool)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BaseAuction__getStatisticsResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBoolean(),
      ),
    );
  }

  getTimeRemaining(): BigInt {
    let result = super.call(
      "getTimeRemaining",
      "getTimeRemaining():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_getTimeRemaining(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getTimeRemaining",
      "getTimeRemaining():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getWinnerInfo(): BaseAuction__getWinnerInfoResult {
    let result = super.call(
      "getWinnerInfo",
      "getWinnerInfo():(address,uint256,bool)",
      [],
    );

    return new BaseAuction__getWinnerInfoResult(
      result[0].toAddress(),
      result[1].toBigInt(),
      result[2].toBoolean(),
    );
  }

  try_getWinnerInfo(): ethereum.CallResult<BaseAuction__getWinnerInfoResult> {
    let result = super.tryCall(
      "getWinnerInfo",
      "getWinnerInfo():(address,uint256,bool)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BaseAuction__getWinnerInfoResult(
        value[0].toAddress(),
        value[1].toBigInt(),
        value[2].toBoolean(),
      ),
    );
  }

  hasNFT(): boolean {
    let result = super.call("hasNFT", "hasNFT():(bool)", []);

    return result[0].toBoolean();
  }

  try_hasNFT(): ethereum.CallResult<boolean> {
    let result = super.tryCall("hasNFT", "hasNFT():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  hasReservePrice(): boolean {
    let result = super.call("hasReservePrice", "hasReservePrice():(bool)", []);

    return result[0].toBoolean();
  }

  try_hasReservePrice(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "hasReservePrice",
      "hasReservePrice():(bool)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isActive(): boolean {
    let result = super.call("isActive", "isActive():(bool)", []);

    return result[0].toBoolean();
  }

  try_isActive(): ethereum.CallResult<boolean> {
    let result = super.tryCall("isActive", "isActive():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  isReadyForBidding(): BaseAuction__isReadyForBiddingResult {
    let result = super.call(
      "isReadyForBidding",
      "isReadyForBidding():(bool,string)",
      [],
    );

    return new BaseAuction__isReadyForBiddingResult(
      result[0].toBoolean(),
      result[1].toString(),
    );
  }

  try_isReadyForBidding(): ethereum.CallResult<BaseAuction__isReadyForBiddingResult> {
    let result = super.tryCall(
      "isReadyForBidding",
      "isReadyForBidding():(bool,string)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new BaseAuction__isReadyForBiddingResult(
        value[0].toBoolean(),
        value[1].toString(),
      ),
    );
  }

  minimumBid(): BigInt {
    let result = super.call("minimumBid", "minimumBid():(uint256)", []);

    return result[0].toBigInt();
  }

  try_minimumBid(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("minimumBid", "minimumBid():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  nftClaimed(): boolean {
    let result = super.call("nftClaimed", "nftClaimed():(bool)", []);

    return result[0].toBoolean();
  }

  try_nftClaimed(): ethereum.CallResult<boolean> {
    let result = super.tryCall("nftClaimed", "nftClaimed():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  nftContract(): Address {
    let result = super.call("nftContract", "nftContract():(address)", []);

    return result[0].toAddress();
  }

  try_nftContract(): ethereum.CallResult<Address> {
    let result = super.tryCall("nftContract", "nftContract():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  nftDeposited(): boolean {
    let result = super.call("nftDeposited", "nftDeposited():(bool)", []);

    return result[0].toBoolean();
  }

  try_nftDeposited(): ethereum.CallResult<boolean> {
    let result = super.tryCall("nftDeposited", "nftDeposited():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  nftTokenId(): BigInt {
    let result = super.call("nftTokenId", "nftTokenId():(uint256)", []);

    return result[0].toBigInt();
  }

  try_nftTokenId(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("nftTokenId", "nftTokenId():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  refundClaimed(param0: Address): boolean {
    let result = super.call("refundClaimed", "refundClaimed(address):(bool)", [
      ethereum.Value.fromAddress(param0),
    ]);

    return result[0].toBoolean();
  }

  try_refundClaimed(param0: Address): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "refundClaimed",
      "refundClaimed(address):(bool)",
      [ethereum.Value.fromAddress(param0)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  reserveMet(): boolean {
    let result = super.call("reserveMet", "reserveMet():(bool)", []);

    return result[0].toBoolean();
  }

  try_reserveMet(): ethereum.CallResult<boolean> {
    let result = super.tryCall("reserveMet", "reserveMet():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  revealedBidderCount(): BigInt {
    let result = super.call(
      "revealedBidderCount",
      "revealedBidderCount():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_revealedBidderCount(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "revealedBidderCount",
      "revealedBidderCount():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  revealedTotalVolume(): BigInt {
    let result = super.call(
      "revealedTotalVolume",
      "revealedTotalVolume():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_revealedTotalVolume(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "revealedTotalVolume",
      "revealedTotalVolume():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  revealedWinningBid(): BigInt {
    let result = super.call(
      "revealedWinningBid",
      "revealedWinningBid():(uint256)",
      [],
    );

    return result[0].toBigInt();
  }

  try_revealedWinningBid(): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "revealedWinningBid",
      "revealedWinningBid():(uint256)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  seller(): Address {
    let result = super.call("seller", "seller():(address)", []);

    return result[0].toAddress();
  }

  try_seller(): ethereum.CallResult<Address> {
    let result = super.tryCall("seller", "seller():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  sellerClaimed(): boolean {
    let result = super.call("sellerClaimed", "sellerClaimed():(bool)", []);

    return result[0].toBoolean();
  }

  try_sellerClaimed(): ethereum.CallResult<boolean> {
    let result = super.tryCall("sellerClaimed", "sellerClaimed():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  statisticsRevealed(): boolean {
    let result = super.call(
      "statisticsRevealed",
      "statisticsRevealed():(bool)",
      [],
    );

    return result[0].toBoolean();
  }

  try_statisticsRevealed(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "statisticsRevealed",
      "statisticsRevealed():(bool)",
      [],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  status(): i32 {
    let result = super.call("status", "status():(uint8)", []);

    return result[0].toI32();
  }

  try_status(): ethereum.CallResult<i32> {
    let result = super.tryCall("status", "status():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  winner(): Address {
    let result = super.call("winner", "winner():(address)", []);

    return result[0].toAddress();
  }

  try_winner(): ethereum.CallResult<Address> {
    let result = super.tryCall("winner", "winner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  winnerRevealed(): boolean {
    let result = super.call("winnerRevealed", "winnerRevealed():(bool)", []);

    return result[0].toBoolean();
  }

  try_winnerRevealed(): ethereum.CallResult<boolean> {
    let result = super.tryCall("winnerRevealed", "winnerRevealed():(bool)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this);
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this);
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }
}

export class ClaimPaymentCall extends ethereum.Call {
  get inputs(): ClaimPaymentCall__Inputs {
    return new ClaimPaymentCall__Inputs(this);
  }

  get outputs(): ClaimPaymentCall__Outputs {
    return new ClaimPaymentCall__Outputs(this);
  }
}

export class ClaimPaymentCall__Inputs {
  _call: ClaimPaymentCall;

  constructor(call: ClaimPaymentCall) {
    this._call = call;
  }
}

export class ClaimPaymentCall__Outputs {
  _call: ClaimPaymentCall;

  constructor(call: ClaimPaymentCall) {
    this._call = call;
  }
}

export class ClaimPrizeCall extends ethereum.Call {
  get inputs(): ClaimPrizeCall__Inputs {
    return new ClaimPrizeCall__Inputs(this);
  }

  get outputs(): ClaimPrizeCall__Outputs {
    return new ClaimPrizeCall__Outputs(this);
  }
}

export class ClaimPrizeCall__Inputs {
  _call: ClaimPrizeCall;

  constructor(call: ClaimPrizeCall) {
    this._call = call;
  }
}

export class ClaimPrizeCall__Outputs {
  _call: ClaimPrizeCall;

  constructor(call: ClaimPrizeCall) {
    this._call = call;
  }
}

export class ClaimRefundCall extends ethereum.Call {
  get inputs(): ClaimRefundCall__Inputs {
    return new ClaimRefundCall__Inputs(this);
  }

  get outputs(): ClaimRefundCall__Outputs {
    return new ClaimRefundCall__Outputs(this);
  }
}

export class ClaimRefundCall__Inputs {
  _call: ClaimRefundCall;

  constructor(call: ClaimRefundCall) {
    this._call = call;
  }
}

export class ClaimRefundCall__Outputs {
  _call: ClaimRefundCall;

  constructor(call: ClaimRefundCall) {
    this._call = call;
  }
}

export class DepositNFTCall extends ethereum.Call {
  get inputs(): DepositNFTCall__Inputs {
    return new DepositNFTCall__Inputs(this);
  }

  get outputs(): DepositNFTCall__Outputs {
    return new DepositNFTCall__Outputs(this);
  }
}

export class DepositNFTCall__Inputs {
  _call: DepositNFTCall;

  constructor(call: DepositNFTCall) {
    this._call = call;
  }
}

export class DepositNFTCall__Outputs {
  _call: DepositNFTCall;

  constructor(call: DepositNFTCall) {
    this._call = call;
  }
}

export class EndAuctionCall extends ethereum.Call {
  get inputs(): EndAuctionCall__Inputs {
    return new EndAuctionCall__Inputs(this);
  }

  get outputs(): EndAuctionCall__Outputs {
    return new EndAuctionCall__Outputs(this);
  }
}

export class EndAuctionCall__Inputs {
  _call: EndAuctionCall;

  constructor(call: EndAuctionCall) {
    this._call = call;
  }
}

export class EndAuctionCall__Outputs {
  _call: EndAuctionCall;

  constructor(call: EndAuctionCall) {
    this._call = call;
  }
}

export class PlaceBidCall extends ethereum.Call {
  get inputs(): PlaceBidCall__Inputs {
    return new PlaceBidCall__Inputs(this);
  }

  get outputs(): PlaceBidCall__Outputs {
    return new PlaceBidCall__Outputs(this);
  }
}

export class PlaceBidCall__Inputs {
  _call: PlaceBidCall;

  constructor(call: PlaceBidCall) {
    this._call = call;
  }

  get encryptedBid(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get inputProof(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class PlaceBidCall__Outputs {
  _call: PlaceBidCall;

  constructor(call: PlaceBidCall) {
    this._call = call;
  }
}

export class ReclaimNFTCall extends ethereum.Call {
  get inputs(): ReclaimNFTCall__Inputs {
    return new ReclaimNFTCall__Inputs(this);
  }

  get outputs(): ReclaimNFTCall__Outputs {
    return new ReclaimNFTCall__Outputs(this);
  }
}

export class ReclaimNFTCall__Inputs {
  _call: ReclaimNFTCall;

  constructor(call: ReclaimNFTCall) {
    this._call = call;
  }
}

export class ReclaimNFTCall__Outputs {
  _call: ReclaimNFTCall;

  constructor(call: ReclaimNFTCall) {
    this._call = call;
  }
}

export class RejectCall extends ethereum.Call {
  get inputs(): RejectCall__Inputs {
    return new RejectCall__Inputs(this);
  }

  get outputs(): RejectCall__Outputs {
    return new RejectCall__Outputs(this);
  }
}

export class RejectCall__Inputs {
  _call: RejectCall;

  constructor(call: RejectCall) {
    this._call = call;
  }
}

export class RejectCall__Outputs {
  _call: RejectCall;

  constructor(call: RejectCall) {
    this._call = call;
  }
}

export class RevealStatisticsCall extends ethereum.Call {
  get inputs(): RevealStatisticsCall__Inputs {
    return new RevealStatisticsCall__Inputs(this);
  }

  get outputs(): RevealStatisticsCall__Outputs {
    return new RevealStatisticsCall__Outputs(this);
  }
}

export class RevealStatisticsCall__Inputs {
  _call: RevealStatisticsCall;

  constructor(call: RevealStatisticsCall) {
    this._call = call;
  }

  get decryptedTotal(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get proof(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class RevealStatisticsCall__Outputs {
  _call: RevealStatisticsCall;

  constructor(call: RevealStatisticsCall) {
    this._call = call;
  }
}

export class RevealWinnerCall extends ethereum.Call {
  get inputs(): RevealWinnerCall__Inputs {
    return new RevealWinnerCall__Inputs(this);
  }

  get outputs(): RevealWinnerCall__Outputs {
    return new RevealWinnerCall__Outputs(this);
  }
}

export class RevealWinnerCall__Inputs {
  _call: RevealWinnerCall;

  constructor(call: RevealWinnerCall) {
    this._call = call;
  }

  get decryptedIndex(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get decryptedBid(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get abiEncodedClearValues(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get decryptionProof(): Bytes {
    return this._call.inputValues[3].value.toBytes();
  }
}

export class RevealWinnerCall__Outputs {
  _call: RevealWinnerCall;

  constructor(call: RevealWinnerCall) {
    this._call = call;
  }
}

export class SetReservePriceCall extends ethereum.Call {
  get inputs(): SetReservePriceCall__Inputs {
    return new SetReservePriceCall__Inputs(this);
  }

  get outputs(): SetReservePriceCall__Outputs {
    return new SetReservePriceCall__Outputs(this);
  }
}

export class SetReservePriceCall__Inputs {
  _call: SetReservePriceCall;

  constructor(call: SetReservePriceCall) {
    this._call = call;
  }

  get encryptedReserve(): Bytes {
    return this._call.inputValues[0].value.toBytes();
  }

  get inputProof(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }
}

export class SetReservePriceCall__Outputs {
  _call: SetReservePriceCall;

  constructor(call: SetReservePriceCall) {
    this._call = call;
  }
}
